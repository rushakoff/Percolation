Notes:
Script contains Encode function, but no mention of encode function within PDF.

Constructor was incorrectly named, causing an error. Constructor and class must have the same name.

PDF instructions mention the use of methods union(), find(), connected(), and
count(). but didn't explain how to use them.

Preproject Preperations:
    To prep for this project I contacted a friend I have who is a recently graduated CS major in another state. (I am very antisocial so most my friends are online). Since this was my first real experience with java I had him give me a long crashcourse through java syntax. Had him further explain exactly what classes are, and how they are used. How to do basic things like creating and initializing lists and variables. How to change and store data, call functions correctly, and many more basics which I am well familiar with in python but struggled greating with understanding in java. The language is so different and some of the most simple things in python are much more verbose and tricky in java. There were several times during the project I needed to ask him to check my syntax on a line of code, due to there being so much to remember so quickly, and me easily forgetting. After this project though I feel I have a much better grasp and understanding of python in general. To the point I am now able to understand much better the slides in class and was able complete the in class stack/queue excercise with plenty of time to spare. I realize that exercise was intentionally very easy, but before this prep I honestly don't know if I would have been able to do that exercise at all. 
    
Question1 writeup and thoughts:
    The hardest part of this project so far has been figuring out how to write in java syntax. I've never used java before and after 4 months of python I am really struggling with transitioning. I really wish our first project was more in line with introducing us to the language. That said I think that might have been the intent? Further into the assignment, when I was near completion I noticed that the project instructions mention various functions but I could not find anywhere in the assignment that explained what these functions are for or how to use them. I noticed it imported the same library as the node connection program shown in class but the instructions just weren't clear enough as to how we could use it for our percolation problem. I understand how it could be used conceptually but again I am just too unfamiliar with java and the library itself to make any use of it. 
    I ended up creating my own pathing algorithm to find out if a matrix percolates or not. I first did this by finding the top starting node, then testing each cardinal direction to see if there was a path that could be traversed. To handle the bounderies of the matrix when searching for paths, I used a Try/Catch to see if checking a path node would lead to an out of bounds error and only continue if not. Later I realized that java doesn't handle out of bounds the way I originally thought. Out of bounds numbers seemed to wrap around to the other side sometimes, to handle this I test to see if each direction would lead to a number greater or less than the matrix's bounds. 
    As I was implementing this I realized I needed to find a way to check every possible fork in a path, as my current algorithm only followed a single path to the end before testing a new starting node. This would cause an issue for pathways that would branch, with the successful branch possibly never being tested. To fix this I created a stack of every possible path from my current node along the test (note: this was written before the stacks and queues class where we learned the java implementation of a stack. by this I meant I implemented an algorithm that works similar to a stack before I knew how to implement an actual stack). I test each possible path and remove pathways that have already been tested, then restarting on the last known possible path, until the current node could reach an open node at the bottom.
    Before this section I was unaware of what the 'k' parameter was in the program. Since the class in which we discussed this I have gone back and changed a few of the functions and rewrote the test statements on the cardinal directions. I also needed to make a new matrix to handle the full/empty state of a space as I was originally using the original matrix, changing the number between 0-empty, 1-open, and 2-full. Now the original matrix is never changed unless opening a space, allowing for theoretically any integer above 0 to percolate with any matching integers within the original matrix. I feel like my code looks a lot sloppier now after these rewrites as It had been a couple days and I had to remember again how my code was working and morph it into code that worked a different way. I think if I had understood what k was from the beginning I could have more elegantly designed my code around that desired behavior. 
    
Question 2 writeup and thoughts:
    For percolation stats I started by creating an algorithm for creating a perolation matrix and running a percolation test, opening a random space in the matrix each time. The issue I ran into during this was the way I was opening spaces in the matrix. Originally I found 2 random numbers between 0 and the bounds of the matrix, then checked the corrisponding space of that matrix using the 2 numbers as x and y. If the space wasn't open already, I would open it, otherwise I would find 2 new random numbers and continue this loop until I found a space that wasnt already open. This turned out to be extremely time consuming, especially for large matrixes as the more spaces that openned the lower the probability of finding numbers that corresponded to an unopen space. Leading to sometimes almost infinate testing times.
    To combat this I created a list with as many elements as the matrix has spaces. Each element containing and x and y corresponding to a space in the matrix. I then used random numbers to shuffle that list, rearranging and randomizing the entries. Then as I run through each percolation test I go through the list in order and use the coordinates in each entry to open a space in the matrix until the matrix percolates. I am unsure how well enough this randomizes each space, but it was the fastest and least intensive way I could think of while I was working on it. I'd imagine I could make the shuffle more and more random the more I increase the amount of iterations I looped the shuffler through. (This was written before we learned about bag collections. I haven't looked into bags much yet, but from what I've seen so far, I feel like I might have been able to use them to shuffle my coordinates.)
    Then to find the stats of the tests I at first attempted to create the math functions myself from scratch. Which wasn't too difficult, just time consuming. I was hung up when it came to the need to find the square root of a number, unsure if I could import the java math library or not since it wasn't included at the top. That is when I noticed the import of the stats library. I wasn't sure what it was or how to use it but I found it in the folder and opened it up. Looking through it I noticed it had functions for mean, variation, and standard deviation. Considering I was half way through my own math when I found it I decided to leave my original code in and comment it out, as a visual trail of my thought process. (sidenote: I struggle a lot with reading mathmatical notation in the instructions. I haven't taken a math class in a few years, so I did get my friend to help me read it. Once I had an understanding of how each simple correlates to each function though, the math was seemingly fairly simple, and took the least amount of time.) I really do think that an explaination of how we are expected to use provided classes should be included with the project pdf. Without looking through the imported class I would have never known the mean, variance, and standard devation were ever provided. Had I known earlier it would have helped me a lot more. 
    
What is the backwash problem:
    I am not entirely sure because I could only really find internet resources of people asking how to fix their backwash problem, not really explaining what the backwash problem is. From what I have seen though, people have had problems of their percolations percolating through and then running back up into open spaces at the bottom of their grid. I imagine it is similar to the issue I was having of testing the left direction at the matrix left boundary and it wrapping around to the right. To solve this, before I test each direction I check if the coordinates I'm about to test are within the bounderies of the matrix. Otherwise I skip that directional test. I am not entirely sure if that is the backwash problem or if that is the correct solution but that is the closest experience to it that I had.
    
Citing of sources:
    I didn't actually use many sources for this project. I had a friend to ask syntax questions to, so there wasn't much need to look up syntax online.
    The one thing I did look up was the backwash problem and these are the sites in which I found people who encountered the problem, but didn't find any sites that explained what the backwash exactly problem was.
    https://github.com/alexilyenko/Algorithms1/issues/2
    https://www.reddit.com/r/javahelp/comments/6zr6ev/why_is_there_backwash_in_percolation/
    
Last minute update:
    It is about 9pm on wednesday when I checked my email and saw the message about omitting results with max open spaces in percolationstats. I rushed to figure out a way to do that. Luckily I had left in my previous manual mean calculation and used a check within that to see if the current number in my average list equalled the max spaces in the percolation grid, omitting it from the sum and subtracting the number of those entries from the denominator. as I was doing this I noticed that sum was initialized as an int instead of a double, so I fixed that as well. I also added in a testing message to add some visual feedback while the code calculates its tests. I know the example didn't include this so I don't know if it is allowed or not, but I feel like it helps give feedback to whether the code is working or hanging. Very large matrixes like the 100*100 take an extraordinarily long time. I am not sure if it is due to my code or the severly underpowered virtual machine set up by Swami. 
    
    
